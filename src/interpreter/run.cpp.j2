// This file is autogenerated.
// Do not modify it manually!

#include <array>
#include <functional>
#include <iostream>

#include "interpreter/interpreter.hpp"
#include "generated/handlers.hpp"

namespace pvm {

using State = Interpreter::State;

{% for type in types +%}
{% set mnem = type.mnemonic %}
const std::array<std::function<void(State&, Instr{{ mnem | upper }})>, e{{ mnem | upper }}_OP_NUM> {{ mnem }}DispatchTable{
  {% for instr in type.instrs %}
  &exec_{{ mnem }}_{{ instr }},
  {% endfor %}
};
{% endfor %}

{% for type in types +%}
{% set mnem = type.mnemonic %}
void exec_{{ mnem | upper }}(State &state, Instr instr);
{% endfor %}

std::array<std::function<void(State&, Instr)>, eOPCODE_NUM> opcodeDispatchTable{
  {% for type in types %}
  &exec_{{ type.mnemonic | upper }},
  {% endfor %}
};

{% for type in types +%}
{% set mnem = type.mnemonic %}
void exec_{{ mnem | upper }}(State &state, Instr instr) {
  auto opID = instr.opID;
  auto typedInstr = std::get<Instr{{ mnem | upper }}>(instr.instrVar);
  {{ mnem }}DispatchTable[opID](state, typedInstr);

  {% if not mnem == 'branch' %}
  state.rf.incrementPC();
  {% endif %}

  {% if not mnem == 'halt' %}
  auto pc = state.rf.readPC();
  std::cout << "PC = " << pc << std::endl;
  auto next = state.code.loadInstr(pc);
  opcodeDispatchTable[next.opType](state, next);
  {% endif %}
}
{% endfor %}

void Interpreter::run() {
  auto instr = getInstr();
  opcodeDispatchTable[instr.opType](m_state, instr);
}

}
