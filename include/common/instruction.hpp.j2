// This file is autogenerated.
// Do not modify it manually!

#pragma once

#include <cstdint>
#include <variant>

namespace pvm {

enum OpType : std::uint8_t {
  {% for type in types %}
  e{{ type.mnemonic | upper }},
  {% endfor %}
  eOPCODE_NUM
};

{% for type in types +%}
enum {{ type.mnemonic | capitalize }}OpID : std::uint8_t {
  {% for instr in type.instrs %}
  e{{ type.mnemonic | upper }}_{{ instr | upper }},
  {% endfor %}
  e{{ type.mnemonic | upper }}_OP_NUM
};
{% endfor %}

{% for type in types +%}
struct Instr{{ type.mnemonic | upper }} {
  constexpr static OpType kType = e{{ type.mnemonic | upper }};
  {% for field in type.fields.keys() %}
  std::uint32_t {{ field }};
  {% endfor %}

  class Builder final {
  private:
    {% for field in type.fields.keys() %}
    std::uint32_t m_{{ field }};
    {% endfor %}

  public:
    {% for field in type.fields.keys() +%}
    Builder & {{ field }}(std::uint32_t val) {
      m_{{ field }} = val;
      return *this;
    }
    {% endfor %}

    [[nodiscard]] Instr{{ type.mnemonic | upper }} build() const {
      return Instr{{ type.mnemonic | upper }} {
        {% for field in type.fields.keys() %}
        m_{{ field }},
        {% endfor %}
      };
    }
  };
};
{% endfor%}

struct Instr {
  using InstrVar = std::variant<
    {% for type in types[:-1] %}
    Instr{{ type.mnemonic | upper }},
    {% endfor %}
    Instr{{ types[-1].mnemonic | upper }}
  >;

  std::uint8_t opType;
  std::uint8_t opID;
  InstrVar instrVar;
};

}
